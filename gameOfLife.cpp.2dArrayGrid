#include <ncursesw/ncurses.h>
#include <iostream>
#include <unistd.h>
#include <locale.h>

#define NEAR	8
#define top		0
#define tRight	1
#define right	2
#define bRight	3
#define bot		4
#define bLeft	5
#define left	6
#define tLeft	7

using namespace std;

int termCols;
int termRows;

void wait( float seconds){
	usleep ( seconds * 1e6 );
}

struct Vect {
	int x;
	int y;
};

struct Cell {
	Cell(int,int,bool);
	bool alive;
	Vect pos;
	Cell* neighbors[NEAR] = {};
	void process();
	void draw();
	void relocate(int x, int y);
};

Cell::Cell(int x=0, int y=0, bool alive=true){
	this->pos.x = x;
	this->pos.y = y;
	this->alive = alive;
}

void Cell::process(){
	int aliveNeighbors = 0;

	for(int i=0; i < NEAR; i++){
		Cell* neighbor = this->neighbors[i];
		if(neighbor){
			aliveNeighbors += neighbor->alive;
		}
	}

	if(aliveNeighbors > 3){
		this->alive = false;
	}
	if (aliveNeighbors < 2){
		this->alive = true;
	}
}

void Cell::draw(){
	move(this->pos.y, this->pos.x);
	printw((this->alive ? "█": "░"));
}

struct Grid {
	Vect size;
	int cellCount;
	Cell ** cells;
	Grid(int,int);
	~Grid();
	void update();
	void draw();
};

Grid::Grid(const int w, const int h){
	this->size.x = w;
	this->size.y = h;
	this->cellCount = w*h;
	this->cells = new Cell[h][w];
	for(int i=0; i< (this->cellCount); i++){
		this->cells[i].draw();
	}

	for(int j=0; j<h; j++){
		for(int i=0; i<w; i++){
			// focus on a cell
			Cell focusC = this->cells[j][i];
			// Tell this cell its position
			focusC.pos.x = i;
			focusC.pos.y = j;
			
			

			// Find all its neighbors
			//for(int subY = -1; subY <= 1; subY++){
			//	for(int subX = -1; subX <= 1; subX++){
			//		Cell neighbor = this->cells[(j+subY)*w+i+subX];
			//		// exclude itself from the list of neighbors
			//		if ((subX != 0)){
			//			focusC.neighbors[k] = &neighbor;
			//			k++;
			//		}
			//	}
			//}
		}
	}
}
Grid::~Grid(){
	delete[] this->cells;
}
void Grid::update(){
	for(int j=0; j< (this->size.y); j++){
		for(int i=0; i< (this->size.x); i++){
			this->cells[i].process();
		}
	}
}
void Grid::draw(){
	for(int j=0; j< (this->size.y); j++){
		for(int i=0; i< (this->size.x); i++){
			this->cells[i].draw();
		}
	}
}

int main (void)
{
	setlocale(LC_ALL,"");
	initscr();
	noecho();

	Grid myG = Grid(10,10);
	while(1){
		getmaxyx(stdscr, termCols, termRows);
		myG.update();
		myG.draw();
		refresh();
		wait(0.5);
	}
	endwin();
	return 0;
}
